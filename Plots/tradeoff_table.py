import pickle
import glob
import re
import matplotlib.pyplot as plt
from collections import defaultdict
import matplotlib.cm as cm

# Most code in this script is generated by ChatGPT based on very detailed promts and then adjusted to fit what was wanted


# --- Helper: Extract lambda value from filename ---
def extract_lambda(filepath):
    match = re.search(r'lambda(\d+)', filepath)
    return int(match.group(1)) if match else float('inf')

# Load and sort files
file_paths = sorted(glob.glob("Saves/lambda*_saved_scheduler_data_FTR.pkl"), key=extract_lambda)

# Load all values into a dictionary for lamb
lambda_data = {}

for path in file_paths:
    with open(path, 'rb') as f:
        data = pickle.load(f)
    lamb = data.get("ftr_penalty_lambda")
    if lamb is not None:
        lambda_data[lamb] = {
            "pen_a": data.get("ftr_weighted_penalty_after"),
            "dist_a": data.get("total_km_after"),
            "rev_a": data.get("expected_revisits_after")
        }

# Extract baseline values from lamb=0
baseline = lambda_data.get(0)
if not baseline:
    raise ValueError("lamb=0 (baseline) is required in the data.")

pen_0 = baseline["pen_a"]
dist_0 = baseline["dist_a"]
rev_0 = baseline["rev_a"]

# Build LaTeX table rows
rows = []
for lamb in sorted(lambda_data):
    pen = lambda_data[lamb]["pen_a"]
    dist = lambda_data[lamb]["dist_a"]
    rev = lambda_data[lamb]["rev_a"]

    if lamb == 0:
        row = f"{lamb} & {round(dist, 2)} & - & {round(pen, 2)} & - & {round(rev, 2)} & - \\\\"
    else:
        row = f"{lamb} & {round(dist, 2)} & {round(dist - dist_0, 2)} & {round(pen, 2)} & {round(pen - pen_0, 2)} & {round(rev, 2)} & {round(rev - rev_0, 2)} \\\\"

    rows.append(row) 

# LaTeX table output
latex_table = r"""
\begin{table}[H]
\centering
\caption{Effect of FTR penalty on key metrics. $\lambda=0$ represents the baseline.}
\begin{tabular}{lcccccc}
\toprule
$\lambda$ & Dist & $\Delta$Dist & Penalty & $\Delta$Penalty & \#Revisits & $\Delta$Revisits \\
\midrule
""" + "\n".join(rows) + r"""
\bottomrule
\end{tabular}
\end{table}
"""


# Print LaTeX table
print(latex_table)

# --- Group lamb values by (dist, pen) pair ---
grouped_points = defaultdict(list)
for lamb, result in lambda_data.items():
    dist = round(result["dist_a"],30)
    pen = round(result["pen_a"],30)
    grouped_points[(dist, pen)].append(lamb)

# Sort by smallest lambda in each group
sorted_points = sorted(grouped_points.items(), key=lambda item: min(item[1]))

# --- Plot with color-coded legend ---
plt.figure(figsize=(10, 7))
cmap = cm.get_cmap("tab20b", len(sorted_points))
colors = [cmap(i) for i in range(len(sorted_points))]

# Background line for structure
plt.plot([x for (x, _), _ in sorted_points],
         [y for (_, y), _ in sorted_points],
         linestyle='-', color='gray', alpha=0.4)

# Plot individual labeled points
for i, ((dist, pen), lambdas) in enumerate(sorted_points):
    label = f"lamb={lambdas[0]}" if len(lambdas) == 1 else f"lamb={min(lambdas)}-{max(lambdas)}"
    plt.plot(dist, pen, marker='o', color=colors[i], label=label)

plt.legend(title="Penalty Weights", loc="best", fontsize=9)
plt.xlabel("Distance (km)")
plt.ylabel("Penalty")
#plt.title("Pareto Front: Trade-off Between Distance and Revisit Penalty")
plt.grid(True)
plt.tight_layout()
plt.savefig("Plots/pareto.png", format="png", dpi=300, bbox_inches="tight")
plt.show()



#_______________________________________________
##For TSP insertion heuristic. 
# ______________________________________________
import os
import re
import pickle
import glob
import matplotlib.pyplot as plt
from collections import defaultdict
import matplotlib.cm as cm

# Helper functions
def extract_lambda_pair(filepath):
    match = re.search(r'lambda(\d+)[^\d]?(\d+)', filepath)
    if match:
        return int(match.group(1)), int(match.group(2))
    return None, None

# Load baseline
with open("Saves/lambda0_0_total_revisit_summary.pkl", "rb") as f:
    baseline_data = pickle.load(f)

#print(baseline_data)

pen_0 = baseline_data["ftr_weighted_penalty_after"]
dist_0 = baseline_data["total_km_after"]
rev_0 = baseline_data["expected_revisits_after"]
##num_added_baseline=baseline_data["customers placed"]

# Load all results
summary_files = sorted(glob.glob("Saves/lambda*_total_revisit_summary.pkl"))
lambda_data = {}

for path in summary_files:
    filename = os.path.basename(path)
    lamb1, lamb2 = extract_lambda_pair(filename)
    if lamb1 is None or lamb2 is None:
        continue  # Skip malformed filenames

    with open(path, "rb") as f:
        data = pickle.load(f)

    num_customers = 0
    diff_path = path.replace("total_revisit_summary", "differences_revisits")
    if os.path.exists(diff_path):
        with open(diff_path, "rb") as f_diff:
            differences = pickle.load(f_diff)
            #print("differences:",diff_path)
            num_customers = len(differences)

    lambda_data[(lamb1, lamb2)] = {
        "pen_a": data["ftr_weighted_penalty_after"],
        "dist_a": data["total_km_after"],
        "rev_a": data["expected_revisits_after"],
        "num_added": num_customers
    }

#print(lambda_data)

# Create LaTeX table
rows = []
for (lamb1, lamb2), result in sorted(lambda_data.items(), key=lambda x: (x[0][0], x[0][1])):
    pen = result["pen_a"]
    dist = result["dist_a"]
    rev = result["rev_a"]
    num_added = result["num_added"]

    #print(lamb1,lamb2)
    if lamb1==0 and lamb2==0:
        row = f"{lamb1} & {lamb2} & {round(dist, 2)} & - & {round(pen, 2)} & - & {round(rev, 2)} & - & {num_added} \\\\"
    else:
        row = f"{lamb1} & {lamb2} & {round(dist, 2)} & {round(dist - dist_0, 2)} & {round(pen, 2)} & {round(pen - pen_0, 2)} & {round(rev, 2)} & {round(rev - rev_0, 2)} & {num_added} \\\\"
    rows.append(row)

latex_table = r"""
\begin{table}[H]
\centering
\caption{Effect of MDVSP and TSP penalty weights on key metrics. $(\lambda_1,\lambda_2) = (0,0)$ is the baseline.}
\begin{tabular}{llccccccc}
\toprule
$\lambda_1$ & $\lambda_2$ & Dist & $\Delta$Dist & Penalty & $\Delta$Penalty & \#Revisits & $\Delta$Revisits & \#Cust. Placed \\
\midrule
""" + "\n".join(rows) + r"""
\bottomrule
\end{tabular}
\end{table}
"""

print(latex_table)
#____________________________________________________
#Plot

plt.rcParams.update({
    'font.size': 13
})

import os
import re
import pickle
import glob
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from collections import defaultdict

# Helper to extract (lambda1, lambda2) from filename
def extract_lambda_pair(filepath):
    match = re.search(r'lambda(\d+)[^\d]?(\d+)', filepath)
    if match:
        return int(match.group(1)), int(match.group(2))
    return None, None

# Load all results
summary_files = sorted(glob.glob("Saves/lambda*_total_revisit_summary.pkl"))
lambda_data = defaultdict(list)  # {lamb1: list of (lamb2, dist, pen)}

for path in summary_files:
    filename = os.path.basename(path)
    lamb1, lamb2 = extract_lambda_pair(filename)
    if lamb1 is None or lamb2 is None or (lamb1!=0 and lamb2 in [0, 1000, 10000,50000]):
        continue

    with open(path, "rb") as f:
        data = pickle.load(f)

    dist = data["total_km_after"]
    pen = data["ftr_weighted_penalty_after"]
    lambda_data[lamb1].append((lamb2, dist, pen))

# --- Plot ---
plt.figure(figsize=(10, 7))
cmap = cm.get_cmap("tab10", len(lambda_data))
colors = [cmap(i) for i in range(len(lambda_data))]

for i, (lamb1, points) in enumerate(sorted(lambda_data.items())):
    # Sort by lamb2 to create consistent lines
    points_sorted = sorted(points, key=lambda x: x[0])
    dist_vals = [p[1] for p in points_sorted]
    pen_vals = [p[2] for p in points_sorted]

    label = f"$\\lambda_1$ = {lamb1}"
    marker_style = 'x' if lamb1 == 0 else 'o'
    color_style=colors[i] if lamb1 != 0 else 'black'
    plt.scatter(dist_vals, pen_vals, marker=marker_style, label=label, color=color_style)

plt.xlabel("Distance (km)")
plt.ylabel("FTR Penalty")
plt.legend(fontsize=13, loc="best")
plt.grid(True)
plt.tight_layout()
plt.savefig("Plots/pareto_by_lambda1_varying_lambda2.png", dpi=300, bbox_inches="tight")
plt.show()



import os
import re
import pickle
import glob
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from collections import defaultdict
from matplotlib.colors import ListedColormap


# Helper: extract (lambda1, lambda2) from filename
def extract_lambda_pair(filepath):
    match = re.search(r'lambda(\d+)[^\d]?(\d+)', filepath)
    if match:
        return int(match.group(1)), int(match.group(2))
    return None, None

# Load results
summary_files = sorted(glob.glob("Saves/lambda*_total_revisit_summary.pkl"))
lambda_data = defaultdict(list)
baseline_point = None



for path in summary_files:
    filename = os.path.basename(path)
    lamb1, lamb2 = extract_lambda_pair(filename)
    if lamb1 is None or lamb2 is None:
        continue

    with open(path, "rb") as f:
        data = pickle.load(f)

    dist = data["total_km_after"]
    pen = data["ftr_weighted_penalty_after"]

    if (lamb1, lamb2) == (0, 0):
        baseline_point = (dist, pen)
    else:
        lambda_data[lamb1].append((lamb2, dist, pen))

# Unique lambda2 values for coloring
all_lambda2 = sorted({lamb2 for values in lambda_data.values() for (lamb2, _, _) in values if lamb2 not in [0, 1000, 10000, 50000]})


cmap = ListedColormap(plt.get_cmap('Set1').colors[:len(all_lambda2)])
color_map = {lamb2: cmap(i) for i, lamb2 in enumerate(all_lambda2)}

# Create subplots
num_plots = len(lambda_data)
fig, axes = plt.subplots(1, num_plots, figsize=(5 * num_plots, 6), sharex=True, sharey=True)

if num_plots == 1:
    axes = [axes]

for i, (ax, (lamb1, values)) in enumerate(zip(axes, sorted(lambda_data.items()))):
    # Plot baseline
    if baseline_point:
        ax.scatter(*baseline_point, color='black', marker='x', s=70)

    # Plot lambda2 points
    for lamb2, dist, pen in values:
        if lamb2 in [0, 1000, 10000,50000]:
            continue
        ax.scatter(dist, pen, color=color_map[lamb2],s=60)

    ax.set_title(f"$\\lambda_1 = {lamb1}$")
    ax.set_xlabel("Distance (km)")

    if i == 0:
        ax.set_ylabel("FTR Penalty")  # Keep full y-axis on first plot
    else:
        ax.set_ylabel("")             # No label
        ax.tick_params(labelleft=False)  # Hide tick numbers on y-axis

    ax.grid(True)

# Custom legend (built once)
handles = [
    plt.Line2D([0], [0], marker='o', linestyle='', color=color_map[lamb2], label=f"$\\lambda_2$ = {lamb2}")
    for lamb2 in all_lambda2
]
handles.append(plt.Line2D([0], [0], marker='x', linestyle='', color='black', label="Baseline"))


plt.tight_layout(rect=[0, 0, 1, 1])  # Leave space on top for legend
plt.subplots_adjust(top=0.80,wspace=0.01) #shifts the usable plotting space a bit down.

# Add horizontal legend above all subplots
fig.legend(
    handles=handles,
    loc='upper center',
    ncol=len(handles),  # One column per item for horizontal layout
    bbox_to_anchor=(0.5, 0.98),
    frameon=True,
    fontsize=18
)
#plt.legend(handles=handles, title="Legend", loc='center left', bbox_to_anchor=(1.05, 0.5))
plt.savefig("Plots/final_lambda1_subplots_with_legend.png", dpi=300, bbox_inches="tight")
plt.show()



#______________________for lambda_1=80______________________________________
import os
import re
import pickle
import glob
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from collections import defaultdict
from matplotlib.colors import ListedColormap

# Helper: extract (lambda1, lambda2) from filename
def extract_lambda_pair(filepath):
    match = re.search(r'lambda(\d+)[^\d]?(\d+)', filepath)
    if match:
        return int(match.group(1)), int(match.group(2))
    return None, None

# Load results
summary_files = sorted(glob.glob("Saves/lambda*_total_revisit_summary.pkl"))
lambda_data = defaultdict(list)
baseline_point = None

for path in summary_files:
    filename = os.path.basename(path)
    lamb1, lamb2 = extract_lambda_pair(filename)
    if lamb1 is None or lamb2 is None:
        continue

    with open(path, "rb") as f:
        data = pickle.load(f)

    dist = data["total_km_after"]
    pen = data["ftr_weighted_penalty_after"]

    if (lamb1, lamb2) == (0, 0):
        baseline_point = (dist, pen)
    else:
        lambda_data[lamb1].append((lamb2, dist, pen))

# --- Filter for lambda1 = 80 only ---
target_lambda1 = 80
values = lambda_data.get(target_lambda1, [])

# Unique lambda2 values for coloring
all_lambda2 = sorted({lamb2 for (lamb2, _, _) in values})
cmap = ListedColormap(plt.get_cmap('tab10').colors[:len(all_lambda2)])
color_map = {lamb2: cmap(i) for i, lamb2 in enumerate(all_lambda2)}

# Create single plot
plt.figure(figsize=(8, 6))

# Plot baseline
if baseline_point:
    plt.scatter(*baseline_point, color='black', marker='x', s=70, label="Baseline")

# Plot lambda2 points for lambda1 = 80
for lamb2, dist, pen in values:
    plt.scatter(dist, pen, color=color_map[lamb2], s=60, label=f"$\\lambda_2$ = {lamb2}")

plt.xlabel("Distance (km)")
plt.ylabel("FTR Penalty")
plt.title(f"$\\lambda_1 = {target_lambda1}$")
plt.grid(True)

# Create legend on the right
handles = [
    plt.Line2D([0], [0], marker='o', linestyle='', color=color_map[lamb2], label=f"$\\lambda_2$ = {lamb2}")
    for lamb2 in all_lambda2
]
handles.append(plt.Line2D([0], [0], marker='x', linestyle='', color='black', label="Baseline"))

plt.legend(
    handles=handles,
    loc='center left',
    bbox_to_anchor=(1.01, 0.5),
    frameon=True,
    fontsize=12
)

plt.tight_layout()
plt.savefig("Plots/lambda1_80_with_legend_right.png", dpi=300, bbox_inches="tight")
plt.show()
